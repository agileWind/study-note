# 第九章 泛型

[TOC]

## 9.1 泛型概述

* 在jdk1.5之前只能把元素类型设计成Object，jdk1.5之后使用泛型来解决。因为这个时候除了元素的类型不确定，其他的部分是确定的。

* 所谓泛型，就是允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值以及参数类型。这个类型参数将在使用时(继承或实现这个接口，用这个类型声明变量，创建对象)确定

* 从jdk1.5之后，Java引入了“参数化类型”的概念，允许我们在创建集合时再指定集合元素的类型，如`List<String>`表明该List只能保存字符串类型的对象

* jdk1.5改写了集合框架中的全部接口和类，为这些接口、类增加了泛型支持，从而可以在声明集合变量、创建集合对象时传入类型实参

## 9.2 泛型使用

* 泛型的类型必须是类，不能是基本数据类型，需要用到基本数据类型的位置，用包装类来代替
* 泛型没有指定的时候默认类型是java.lang.Object
* 类型推断：`ArrayList<String> list=new ArrayList();`
  也就是说后面实例化可省略类型不写

```java
public class GenericTest {
    public static void main(String[] args) {
        ArrayList<Integer> list=new ArrayList<Integer>();
        list.add(89);
        list.add(100);
        list.add(83);
        list.add(39);
        Iterator<Integer> iterator=list.iterator();
        while(iterator.hasNext()){
            int score=iterator.next();
            System.out.println(score);
        }

        ArrayList list2=new ArrayList();
        list2.add(89);
        list2.add(100);
        list2.add(83);
        list2.add(39);
        Iterator iterator2=list2.iterator();
        while(iterator2.hasNext()){

            int score=(Integer) iterator2.next();//没有声明泛型则默认元素类型是Object类型，需要强转
            System.out.println(score);
        }

        Map<String,Integer> map=new HashMap<String,Integer>();
        map.put("Tom",44);
        map.put("Jack",94);
        map.put("Jerry",78);

        Set<Map.Entry<String,Integer>> entries=map.entrySet();
        Iterator<Map.Entry<String,Integer>> iterator1=entries.iterator();
        while(iterator1.hasNext()){
            Map.Entry<String,Integer> e=iterator1.next();
            String key=e.getKey();
            int score=e.getValue();
            System.out.println(key+"--->"+score);
        }
    }
}
```

* 在Comparable接口的使用中运用泛型，在Comparator接口实现类中使用泛型，如下：

```java
public class Test {
    public static void main(String[] args) {
        TreeSet<Person> set = new TreeSet();
        set.add(new Person("Jerry", 105));
        set.add(new Person("Tom", 20));
        set.add(new Person("Mike", 23));
        set.add(new Person("Jack", 12));

        System.out.println(set);//使用自然排序接口Comparable,按照姓名的英文字母排序
        //[Person{name='Jack', age=12}, Person{name='Jerry', age=105}, Person{name='Mike', age=23}, Person{name='Tom', age=20}]

        Comparator<Person> comparator = new Comparator<Person>() {
            @Override
            public int compare(Person p1, Person p2) {
                return Integer.compare(p1.getAge(), p2.getAge());
            }
        };
        TreeSet<Person> set2 = new TreeSet(comparator);
        set2.addAll(set);

        System.out.println(set2);//使用定制排序接口Comparator,按照年龄从小大到排序
        //[Person{name='Jack', age=12}, Person{name='Tom', age=20}, Person{name='Mike', age=23}, Person{name='Jerry', age=105}]
    }
}

class Person implements Comparable<Person> {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Person person = (Person) o;
        return age == person.age &&
                Objects.equals(name, person.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, age);
    }


    @Override
    public int compareTo(Person person) {
        return this.name.compareTo(person.name);
    }
}
```

## 9.3 自定义泛型

* 自定义异常示例如下：

```java
public class MyTest {
    public static void main(String[] args) {
        Fruit fruit=new Fruit("apple","red");
        Box<Fruit> fruitBox=new Box<Fruit>();
        fruitBox.setThing(fruit);
        fruitBox.setWeight(150);
        fruitBox.setDate(new Date());
    }
}

class Box<E>{

    public E thing;
    public double weight;
    public Date date;

    public E getThing() {
        return thing;
    }

    public void setThing(E thing) {
        this.thing = thing;
    }

    public double getWeight() {
        return weight;
    }

    public void setWeight(double weight) {
        this.weight = weight;
    }

    public Date getDate() {
        return date;
    }

    public void setDate(Date date) {
        this.date = date;
    }
}

class Fruit{
    String name;
    String color;

    public Fruit(String name, String color) {
        this.name = name;
        this.color = color;
    }
}
```

* 如果父类使用了泛型，定义子类时可以继续使用泛型，或者在继承的时候指明数据类型

```java
class MyBox extends Box<Fruit>{

}
```

或者：

```java
class MyBox<E> extends Box<E>{

}
```

* 泛型类可能有多个参数，此时应将多个参数一起放在尖括号内，如：<E1,E2,E3>
* 泛型类的构造器如下：public GenericClass(){},而不能写成：public GenericClass<E>(){}
* 实例化后，操作原来泛型位置的结构必须与指定的泛型类型一致
* 泛型不同的引用不能相互赋值
  `ArrayList<Integer> list1=...;`
  `ArrayList<String> list2=...;`
  `list1.addAll(list2);//错误，这两个泛型引用不能相互赋值`
* 泛型类的静态成员不能使用类的泛型参数；泛型方法里面可以独立使用泛型表示不确定的参数类型
* T[] arr=new T[10];错误
  T[] arr=(T[])new Object[10];//编译通过
* 泛型如果不指定，将被擦除，泛型对应的类型按照Object处理，但不等价于Object
* 泛型结构如果是一个接口或抽象类，则无法被实例化
* 泛型的简化写法，类型推断：`ArrayList<String> list=new ArrayList<>();`
* 泛型的指定中不能使用基本数据类型，可以使用包装类替换
* 异常类不能是泛型的
* 父类是泛型，子类可以选择：
  1. 子类不保留父类的泛型：
     * 没有类型，擦除
     * 指明具体类型
  2. 子类保留父类的泛型，泛型子类
     * 全部保留
     * 部分保留
* 子类除了能指定或者保留父类的泛型，还可以增加自己的泛型

## 9.4 泛型方法

* 泛型方法：在方法中出现了泛型结构，泛型参数与类的泛型参数没有任何关系
* 泛型方法所属的类是不是泛型类都没有关系
* 自定义泛型方法示例：

```java
public class MyTest {
    public static void main(String[] args) {
        Integer[] arr = new Integer[]{1, 3, 5, 0, 3};
        List<Integer> list = copyFromArrayToList(arr);
        System.out.println(list);
    }

    public static <E> List<E> copyFromArrayToList(E[] arr) {
        ArrayList<E> list = new ArrayList<>();
        for (E e : arr) {
            list.add(e);
        }
        return list;
    }
}
```

* 泛型方法可以声明为静态的，因为泛型参数是在调用方法时确定的，并非在实例化类时确定

* 泛型在继承方面的体现：
  1. 如果类A和类B是继承关系，那么`G<A>`和`G<B`>不具有子父类关系
  2. 如果类A和类B是继承关系，那么`A<C>`和`B<C>`是有关系的

     ```java
     List<Integer> list=null;
     ArrayList<Integer> arrayList=null
     list=arrayList;//可以
     ```

## 9.5 通配符

* 通配符：`?`

```java
List<Object> list1=null;
List<String> list2=null;
List<?> list3=list2;//正确
List list4=list1;//正确,todo
```

* 使用通配符后数据的读取和写入

```java
class Test{
    public static void main(String[] args) {
        List<String> list=new ArrayList<>();
        list.add("AA");
        list.add("cc");
        list.add("bb");
        List<?> list2=list;
        //list2.add("dd");//通配符泛型无法写值

        list2.get(0);//通配符泛型可以读取值，值的类型数据类型是Object
    }
}
```

* 有限制条件的通配符的使用

```java
class Test2 {
    public static void main(String[] args) {
        List<? extends Person> list1 = null;//相当于此时的类型要<=Person
        List<? super Person> list2 = null;//相当于此时的类型要>=Person

        List<Student> list3 = null;
        List<Person> list4 = null;
        List<Object> list5 = null;

        list1=list3;
        Person p1=list1.get(0);//左边只能写Person,写Student不可//todo
        list1=list4;
        //list1=list5;//报错

        //list2=list3;//报错
        list2=list4;
        Object p2=list2.get(0);//左边只能写Object,写Person不可
        list2=list5;

        //list1.add(new Person("Tom",11));//错误
        //list1.add(new Student("Tom",11));//错误

        list2.add(new Person("Tom",11));
        list2.add(new Student("Tom",11));
    }
}
```

```java
Map<String,T> map;
Collection<T> coll=map.values();
List<T> list=(List<T>)coll;//编译通过，允许不通过
```

```java
Map map=new HashMap();
Collection coll=map.values();
System.out.println(coll.getClass);//java.util.HashMap$Values,这不是List的父类型，不能被强转
List list=(List)coll;//编译通过，允许不通过
```
