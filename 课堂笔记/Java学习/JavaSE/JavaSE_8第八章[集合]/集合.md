# 第八章 集合

[TOC]

## 8.1 集合概述

* 集合、数组都是堆多个数据进行存储操作的结构，即Java容器
  说明：这里的存储，说的是内存层面的存储，不涉及到持久化的存储

* 数组存储多个数据的特点：
  1. 一旦初始化，其长度就确定了
  2. 一旦定义好，其元素的类型也就确定了，只能操作指定类型的数据，比如`String[] arr;`、`int[] arr1;`、`Object[] arr2;`
* 数组存储多个数据的缺点：
  1. 一旦存储初始化以后，其长度就不可修改
  2. 数组中提供的方法非常有限，对于添加、删除、插入数据等操作，非常不便，且效率不高
  3. 获取数组中实际元素的个数的需求，数组没有现成的属性或方法可用
  4. 数组存储数据的特点：有序(前后顺序)、可重复

## 8.2 集合框架概述

* Collection接口：单列接口，用来存储一个一个的对象
  * List接口：存储有序的、可重复的数据
    1. ArrayList
    2. LinkedList
    3. Vector
  * Set接口：存储无序的、不可重复的数据
    1. HashSet
    2. LinkedHashSet
    3. TreeSet
* Map接口：双列集合，用来存储一对(key,value)一对的数据
  1. HashMap
  2. LinkedHashMap
  3. TreeMap
  4. Hashtable
  5. Properties

## 8.3 Collection接口以及实现类

### 8.3.1 Collection接口的方法使用

```java
public class CollectionTest {
    public static void main(String[] args) {
        Collection coll=new ArrayList();
        coll.add("AA");
        coll.add("BB");
        coll.add("123");
        coll.add(new Date());
        System.out.println(coll.size());//4

        Collection coll2=new ArrayList();
        coll2.add(456);
        coll2.add("CC");
        coll2.addAll(coll);
        System.out.println(coll2.size());//6

        System.out.println(coll2.isEmpty());//false

        coll2.clear();//清空集合里面的元素
        System.out.println(coll2.isEmpty());//true

        coll2.add("123");
        coll2.add(345);
        coll2.add(new String("hello"));
        coll2.add(false);
        coll2.add(new Person("Tom",12));

        System.out.println(coll2.contains("123"));//true
        System.out.println(coll2.contains(new String("hello")));//true
        System.out.println(coll2.contains(new Person("Tom", 12)));//Person重写了equals则true,没有重写就是比堆中地址
        //contains判断当前集合是否包含一个对象，会去调用对象的equals方法,所以对象所在的类需要重写equals方法来定制比较的规则

        Collection coll3=new ArrayList();
        coll3.add("123");
        coll3.add(345);
        System.out.println(coll2.containsAll(coll3));//true,coll3的元素是否全部都在coll2中存在

        coll3.remove(345);
        coll2.remove(new String("hello"));

        coll2.removeAll(coll3);//coll2中的元素，只要在coll3中也存在，则在coll2中移除coll3中存在的元素，相当于求coll2与coll3的差集

        coll2.retainAll(coll3);//coll2与coll3的交集

        Collection coll4=new ArrayList();
        coll4.add("123");
        coll4.add(456);

        Collection coll5=new ArrayList();
        coll4.add(456);
        coll4.add("123");

        System.out.println(coll4.equals(coll5));//false,Collection是有序的

        //集合---->数组
        Object[] arr=coll4.toArray();

        //数组---->集合
        List<String> list=Arrays.asList(new String[]{"AA","BB","CC"});
        System.out.println(list);

        List list2=Arrays.asList(new int[]{123,345});//基本数据类型，会当成一个整体
        System.out.println(list2.size());//1

        List<Integer> list3=Arrays.asList(new Integer[]{123,345});
        System.out.println(list3.size());//2


    }
}
class Person{
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Person person = (Person) o;
        return age == person.age &&
                Objects.equals(name, person.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, age);
    }
}
```

* 集合的遍历

```java
public class IteratorTest {
    public static void main(String[] args) {
        Collection coll=new ArrayList();
        coll.add(123);
        coll.add(234);
        coll.add(new Person("Tom",20));
        coll.add(new String("hello"));
        coll.add(false);

        Iterator iterator=coll.iterator();

        //遍历方式一
//        System.out.println(iterator.next());//123
//        System.out.println(iterator.next());//234
//        System.out.println(iterator.next());//Person{name='Tom', age=20}
//        System.out.println(iterator.next());//hello
//        System.out.println(iterator.next());//false
//        System.out.println(iterator.next());//此行报错，java.util.NoSuchElementException

        //遍历方式二,不推荐
//        for(int i=0;i<coll.size();i++){
//            System.out.println(iterator.next());
//        }

        //遍历方式三，推荐
        while(iterator.hasNext()){
            System.out.println(iterator.next());
            /**
             * 并发删除异常:在迭代器里删除，确实是删除成功了，但是iterator.next()会报错，因为它会去检查删除元素的次数，发现遍历过程中已被删了一次，就会抛出异常
             * int i=(Integer)iterator.next();
             * if(i==123)
             *     coll.remove(i);//在迭代器里删除集合元素，必须使用迭代器删除
             */
        }
        //iterator.next():指针下移，然后将当前指针指向的元素返回
        //iterator.remove():只有当前指针指向了一个集合元素时，当前元素才能被remove，且只能被remove一次；
        // 然后调用next()指向下一个元素后才能再次调用remove移除当前指针指向的元素

        for(Object obj: coll){//通过debug可以看到，此方法与遍历方式三相同
            System.out.println(obj);
        }

        String[] arr=new String[]{"aa","aa","aa","aa","aa"};
        for(int i=0;i<arr.length;i++){
            arr[i]="bb";
        }
        System.out.println(Arrays.toString(arr));//数组元素全部都是"bb"

        for(String str:arr){
            str="cc";//str是一个局部变量，然后数组元素依次赋给了这个局部变量，当然不会影响原数组的元素值
        }
        System.out.println(Arrays.toString(arr));//数组元素没有变化，仍是"bb"
    }
}
```

* **快速失败机制**

使用迭代器在遍历集合时，如果使用迭代器之外的方法修改了集合的数据，会发生并发修改异常。因为这种操作会给数据带来不可预知的风险。为了防止后期发生更大的问题，java采取了这种机制，直接抛出异常。这就是快速失败机制。实现方式：借助集合中的一个成员变量modCount(用于统计集合中数据修改的次数)

### 8.3.2 List接口

* List接口：存储有序的、可重复的数据，“动态”的数组，替换原有的数组
* ArrayList：作为List接口的主要实现类，线程不安全的，效率高；底层使用Object[]存储
* LinkedList：底层使用双向链表存储；对于频繁的插入、删除的操作比ArrayList更有效率
* Vector：1.0就存在，作为List接口的古老实现类，线程安全的，效率低；底层使用Object[]存储

> 双向链表与(顺序表)数组的操作查阅[数据结构](./../../DataStructure/数据结构.md)

#### List接口中的常用方法

* 因为List是有序的，会有一些根据索引来操作的函数(让子类去实现)

```java
public class ListTest {
    public static void main(String[] args) {
        ArrayList list=new ArrayList();
        list.add(123);
        list.add("AA");
        list.add(new Person("Tom",20));
        list.add(false);
        System.out.println(list);//[123, AA, Person{name='Tom', age=20}, false]
        list.add(1,"BB");
        System.out.println(list);//[123, BB, AA, Person{name='Tom', age=20}, false]

        List list2= Arrays.asList(1111,2222,3333);//返回的List是不可变的，不可添加删除元素
        list.addAll(2,list2);
        System.out.println(list);//[123, BB, 1111, 2222, 3333, AA, Person{name='Tom', age=20}, false]

        System.out.println(list.get(2));//1111
        Object o=list.remove(1);
        list.set(1,"hello");
        List list3=list.subList(1,3);//获取子列表，范围是[1,3)
        System.out.println(list3);//[hello, 2222]

        List list3=new ArrayList<>();
        list3.add(123);
        list3.add(2,234);//报错，只能在list3的元素末尾或者头部或者中间插入新元素

    }
}
```

* 由于remove有两个重载的方法，可以传index，也可以传Object类型的对象，下面有一个实例

```java
public class ListRemoveTest {
    public static void main(String[] args) {
        List list=new ArrayList();
        list.add(1);
        list.add(2);
        list.add(3);
        updateList(list);
        System.out.println(list);//[1,2]
    }

    private static void updateList(List list){
        list.remove(2);//这里的2应该是匹配index；而不是去将基本数据类型装箱成Integer,然后识别成Object的子类对象
        //集合元素是int基本数据类型，此时remove传递数字只会认为是index
    }
}
```

#### ArrayList

* ArrayList的源码分析（jdk7）：
  1. ArrayList list=new ArrayList();//底层创建了长度是10的Object[]数组elementData
  2. `list.add(123);//elementData[0]=new Integer(123)`;
  3. ....
  4. list.add(11);//如果此次的添加导致底层elementData数组容量不够，则扩容。
     默认情况下，扩容为原来的1.5倍容量，同时需要将原有的数组中的数据复制到新的数组中

* jdk8中ArrayList的变化：
  1. ArrayList list=new ArrayList();//底层Object[] elementData初始化为{}，并没有创建长度为10的数组
  2. list.add(123);//第一次调用add()时，底层才创建了长度为10的数组，并将数据添加到elementData数组中
  3. ...//后续和jdk7相同

> 建议使用ArrayList的时候使用带参的构造器，给对象一个初始化的空间

#### LinkedList

* LinkedList还实现了队列Deque(双端队列)的接口，可以实现队列进出的操作和栈的操作
//todo,源码分析

#### Vector

//基本废弃
在多线程中，也是使用ArrayList，虽然不安全，但是通过`Collections`的`SynchronizedList`返回线程安全的ArrayList

### 8.3.2 Set接口

* Set接口：存储无序的、不可重复的数据
  1. HashSet：作为Set接口的主要实现类；线程不安全的；可以存储`null`值
  2. LinkedHashSet:是HashSet的子类，加上了前后指针，即双向链表，遍历其内部数据时，可以按照添加的顺序遍历
  3. TreeSet：红黑树实现，可以按照添加元素的指定属性，进行排序

* Set接口中没有定义自己的方法

* Set特性：
  1. 无序性:不等于随机性。存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值决定的
  2. 不可重复性：保证添加的元素按照equals()判断时，不能返回true，即相同的元素只能添加一个
  3. 添加元素的过程（以HashSet为例）：
     1. 添加元素a,首先调用元素所在类的hashCode()方法，计算元素a的哈希值，此时哈希值接着通过散列函数计算出HashSet底层数组中存放位置(即索引位置)，判断数组此位置上是否有元素
     2. 如果此位置上没有其他元素，即元素a添加成功
     3. 如果此位置上有其他元素b(或以链表形式存在的多个元素),则比较元素a与元素b的hash值，如果hash值不同，则元素a添加成功；如果hash值相同，进而需要调用元素所在类的equals()方法：equals()返回true，元素a添加失败，equals()返回false，则元素a添加成功
     >对于索引位置上已有元素，又在该索引位置插入元素，采用链表的方式存储，新元素插入的方式不同：jdk7将新元素放在数组中，并让新元素指向原来的元素；jdk8令原来的元素还是存在于数组中，并让原来的元素指向新元素
     > HashSet底层：数组和链表的方式存储(jkd7之前)

  4. 要求：向Set中添加的数据，其所在的类一定要重写hashCode()和equals()

#### HashSet

//底层原理是HashMap

```java
public class SetTest {
    public static void main(String[] args) {
        Set set=new HashSet();
        set.add(1);
        set.add(2);
        set.add(3);
        set.add(4);


        Set set2=new HashSet();
        set2.add(4);
        set2.add(2);
        set2.add(3);
        set2.add(1);
        System.out.println(set.equals(set2));//true
    }
}
```

#### LinkedHashSet

它仍然是无序的，但由于它在原有HashSet上添加了双向链表，通过两个指针，就可以按照元素的插入顺序遍历元素，但是它们存储的时候是无序的

#### TreeSet

* 对象要属于同一个类元素，即元素是相同类的对象

* TreeSet在遍历时是按照有序的顺序进行遍历的(也就是在平衡二叉树上进行中序遍历)

* TreeSet添加数据，区分两个对象是否相等，不是使用equals，而是使用了比较，不仅要知道是否相等，还要知道两个对象的大小，比较大小的两个方法：
  1. 自然排序，对象对应的类需要实现Comparable接口，并重写compareTo()方法
  2. 定制排序，需要定义一个实现Comparator接口的类，并实现compare()方法，在创建TreeSet对象时将该实现类的对象传入TreeSet构造器中

```java
public class TreeSetTest {
    public static void main(String[] args) {
        Set set=new TreeSet();
        set.add(2);
        set.add(-7);
        set.add(43);
        set.add(40);

        Iterator iterator=set.iterator();
        while(iterator.hasNext()){
            System.out.println(iterator.next());//依次输出：2，-7，40，43
        }

        System.out.println(Arrays.toString(set.toArray()));//[2，-7，40，43]
    }
}
```

* 因为TreeSet会对元素进行排序，所以当元素类型为自定义引用型类，则需要实现comparable接口，并重写compareTo()方法
  >当然也可以选择定制排序Comparator接口

```java
public class TreeSetTest {
    public static void main(String[] args) {
        Set set=new TreeSet();
        set.add(new Person("Tom",20));
        set.add(new Person("Mike",23));
        set.add(new Person("Jack",12));
        set.add(new Person("Jerry",15));

        Iterator iterator=set.iterator();
        while(iterator.hasNext()){
            System.out.println(iterator.next());
            //依次输出：Person{name='Jack', age=12}, Person{name='Jerry', age=15}, Person{name='Mike', age=23}, Person{name='Tom', age=20}
        }

        System.out.println(Arrays.toString(set.toArray()));
        //[Person{name='Jack', age=12}, Person{name='Jerry', age=15}, Person{name='Mike', age=23}, Person{name='Tom', age=20}]
    }
}
class Person implements Comparable{
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Person person = (Person) o;
        return age == person.age &&
                Objects.equals(name, person.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, age);
    }


    @Override
    public int compareTo(Object o) {
        if(o instanceof Person){
            Person otherPerson=(Person)o;
            return this.name.compareTo(otherPerson.name);
        }else{
            throw new RuntimeException("输入的类型不匹配");
        }
    }
}
```

* 如上实例，区别数据是否相同，是通过比较姓名，如果姓名相同，则认为相同，重复的第二个数据不会被存入到treeSet中

```java
public class TreeSetTest {
    public static void main(String[] args) {
        Set set=new TreeSet();
        set.add(new Person("Tom",20));
        set.add(new Person("Mike",23));
        set.add(new Person("Jack",12));
        set.add(new Person("Jerry",15));
        set.add(new Person("Jerry",105));//该数据不会被存入集合set中
        Iterator iterator=set.iterator();
        while(iterator.hasNext()){
            System.out.println(iterator.next());
        }

        System.out.println(Arrays.toString(set.toArray()));
    }
}
```

> 如果想存入姓名相同，但是年龄不同的数据，可以修改compareTo()方法来修改比较的规则。

* 采用Comparator给TreeSet提供排序

```java
public class TreeSetTest {
    public static void main(String[] args) {
        Comparator comparator=new Comparator() {
            @Override
            public int compare(Object o1, Object o2) {
                if(o1 instanceof Person && o2 instanceof Person){
                    Person p1=(Person)o1;
                    Person p2=(Person)o2;
                    return Integer.compare(p1.getAge(),p2.getAge());
                }else{
                    throw new RuntimeException("数据类型不匹配");
                }
            }
        };

        TreeSet set=new TreeSet(comparator);
        set.add(new Person("Tom",20));
        set.add(new Person("Mike",23));
        set.add(new Person("Jack",12));
        set.add(new Person("Jerry",15));
        set.add(new Person("Jerry",105));
        Iterator iterator=set.iterator();
        while(iterator.hasNext()){
            System.out.println(iterator.next());
            //按照年龄排序，依次输出：Person{name='Jack', age=12}, Person{name='Jerry', age=15}, Person{name='Tom', age=20}, Person{name='Mike', age=23}, Person{name='Jerry', age=105}
        }

        System.out.println(Arrays.toString(set.toArray()));
        //[Person{name='Jack', age=12}, Person{name='Jerry', age=15}, Person{name='Tom', age=20}, Person{name='Mike', age=23}, Person{name='Jerry', age=105}]
    }
}

```

* 对HashSet的理解，有如下示例：

```java
public class HashSetTest {
    public static void main(String[] args) {
        HashSet hashSet=new HashSet();
        Person p1=new Person("Tom",20);
        Person p2=new Person("Jack",23);

        hashSet.add(p1);
        hashSet.add(p2);
        p1.setName("Mike");//修改的属性，但是对象在set中存储的位置没有改变
        hashSet.remove(p1);//此时会根据p1对象来算hashcode，找索引，此时找不到了，因为属性值都变了，
        System.out.println(hashSet);//[Person{name='Mike', age=20}, Person{name='Jack', age=23}]

        hashSet.add(new Person("Mike",20));
        System.out.println(hashSet);//[Person{name='Mike', age=20}, Person{name='Mike', age=20}, Person{name='Jack', age=23}]

        hashSet.add(new Person("Tom",20));
        System.out.println(hashSet);//[Person{name='Mike', age=20}, Person{name='Mike', age=20}, Person{name='Tom', age=20}, Person{name='Jack', age=23}]
    }
}
```

## 8.4 Map接口以及实现类

### Map介绍

* Map接口：双列集合，用来存储一对(key,value)一对的数据
  1. `HashMap`：作为Map的主要实现类线；程不安全的，效率高；**可以**存储`null`的key和value
     * `LinkedHashMap`:保证在遍历map元素时，可以按照添加的顺序实现遍历，因为在原有HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素，即双向链表，对于频繁的遍历操作，此类执行效率高于HashMap
  2. `TreeMap`：保证按照添加的key-value对进行排序，实现排序遍历。考虑key的自然排序和定制排序。底层使用红黑树
  3. `Hashtable`：作为古老的实现类；线程安全的，效率低；**不能**存储`null`的key和value
     * `Properties`：常用来处理配置文件，key和value都是String类型
  > HashMap的底层：数组+链表(jdk7及以前)；数组+链表+红黑树(jdk8)

> 需要了解的知识
>
> 1. HashMap的底层实现原理
> 2. HashMap和HashTable的异同
> 3. CurrentHashMap与HashTable的异同：CurrentHashMap解决高并发多线程访问共享资源（因为HashTable是线程安全，多线程无法同时访问）

### Map结构的理解

* Map中的key:无序的、不可重复的、使用Set存储所有的key         --->key所在的类要重写equals(),hashCode()
* Map中的value:无序的、可重复的、使用Collection存储所有的value   ---->value所在类要重写equals()
* Map中的entry：无序的、不可重复的、使用Set存储所有的entry

### Map的使用

```java
public class MapTest {
    public static void main(String[] args) {
        Map map = new HashMap();
        map.put("AA", 123);
        map.put(45, 123);
        map.put("BB", 34);
        map.put("AA", 999);

        System.out.println(map);//{AA=999, BB=34, 45=123}

        Map map2 = new HashMap();
        map2.put("hello", "111");
        map2.put("world", "222");
        map.putAll(map2);

        System.out.println(map);//{AA=999, BB=34, world=222, hello=111, 45=123}

        map2.clear();//清空map2中的数据
        System.out.println(map2);//{}
        System.out.println(map2.size());

        System.out.println(map.get("AA"));
        System.out.println(map.get("CC"));
        System.out.println(map.containsKey("AA"));
        System.out.println(map.containsValue(123));

        System.out.println(map.isEmpty());


        method();
    }
    public static void method(){
        //元视图
        Map map = new HashMap();
        map.put("AA", 123);
        map.put(45, 123);
        map.put("BB", 34);
        map.put("AA", 999);

        //遍历所有的key集合：keySet()
        Set set=map.keySet();
        Iterator iterator=set.iterator();
        while(iterator.hasNext()){
            System.out.println(iterator.next());
        }

        //遍历所有的value集合：values()
        Collection values=map.values();
        for(Object obj :values){
            System.out.println(obj);
        }

        //遍历所有的key-value：entrySet()
        Set entrySet=map.entrySet();
        Iterator iterator1=entrySet.iterator();
        while(iterator1.hasNext()){
            Object obj=iterator1.next();
            Map.Entry entry=(Map.Entry)obj;
            System.out.println(entry.getKey()+"---->"+entry.getValue());
        }
    }
}
```

### HashMap

* HashMap的底层实现原理(jdk7):
  1. HashMap map=new HashMap();
     在实例化之后，底层创建了长度是16的一维数组Entry[] table
  2. ....
  3. map.put(key1,value1)
     1. 首先，调用key1所在类的hashCode()计算key1的哈希值，此时哈希值经过散列函数后计算得到Entry数组中存放的位置，如果此位置上的数据为空，此时的(key1,value1)添加成功
     2. 如果此位置上的数据不为空(意味着此位置存在一个或多个数据(以链表形式存在))，那么就比较key1与已经存在的一个或多个数据的哈希值：
       (1) 如果key1的哈希值与已经存在的数据的哈希值都不相同，此时(key1,value1)添加成功
       (2) 如果key1y的哈希值和已经存在的某数据(key2,value2)的哈希值相同，继续调用key1的equals比较它们key1.equals(key2)：如果equals返回false,此时(key1,value1)添加成功；如果equals返回true，使用新的value1来替换value2

  4. 扩容问题：默认扩容为原来容量的2倍，并将所有的数据复制过来

* jdk8相较于jdk7在底层实现方面的不同：
  1. new HashMap()：底层没有创建一个长度为16的数组
  2. jdk8底层的数组是：`Node[]`,而非`Entry[]`
  3. 首次调用put()方法时，底层创建长度为16的数组
  4. jdk底层结构只有：数组+链表;jkd8中底层结构：数组+链表+红黑树
     当数组的某一个索引位置上的元素以链表形式存在的数据个数>8 且 当前数组的长度>64 时，此时当前索引位置上的所有数据改为使用红黑树存储

* HashMap源码中的成员常量
  1. DEFUALT_INITIAL_CAPACITY:HashMap的默认容量，16
  2. MAXIMUM_CAPACITY:HashMap的最大支持容量：$2^{30}$
  3. DEFAULT_LOAD_FACTOR:HashMap的默认加载因子
  4. TREEIFY_THRESHOLD:Bucket中链表长度大于该默认值，转化为红黑树
  5. UNTREEIFY_THRESHOLD:Bucket中红黑树存储的Node小于该默认值，转化为链表
  6. MIN_TREEIFY_CAPACITY:桶中的Node被树化时最小的hash表容量。(当桶中Node的数量大到需要变红黑树时)，若hash表容量小于MIN_TREEIFY_CAPACITY时，此时应执行resize扩容操作这个MIN_TREEIFY_CAPACITY的值至少是TREEIFY_THRESHOLD的4倍
  7. table:存储元素的数组，总是$2^n$长度
  8. entrySet:存储具体元素的集
  9. size:HashMap中存储的键值对的数量
  10. modCount:HashMap扩容和结构改变的次数
  11. threshold:扩容的临界值=容量*填充因子
  12. loadFactor:填充因子，默认是0.75

何时扩容：

1. 第一个添加元素，扩容为初始化长度16
2. 链表长度达到8，并且数组长度未达到64时
3. 元素个数达到扩容阈值，扩容为原来容量的2倍

* HashMap源码分析(jdk7)

//todo

* HashMap源码分析(jdk8)
//todo

### LinkedHashMap

### TreeMap

* 要求key必须是同一个类创建的对象
* 创建key值的类需要实现接口Comparable,重写compareTo();或者比较的子类继承Comparator,并重写compare(),这一点与TreeSet相符

```java
package com.suftz.study.day15;

import java.util.*;

/**
 * Description:
 *
 * @author zhangchengy
 * @version 1.0
 * @date 2020/12/6 16:54
 */
public class MapTest {
    public static void main(String[] args) {
    public static void method1(){
        Map map=new TreeMap();
        map.put(new Person("Tom",20),50);
        map.put(new Person("Jack",21),60);
        map.put(new Person("Jerry",23),80);
        map.put(new Person("Alice",19),90);

        System.out.println(map);//按照名字的英文字母排序
        //{Person{name='Alice', age=19}=90, Person{name='Jack', age=21}=60, Person{name='Jerry', age=23}=80, Person{name='Tom', age=20}=50}
    }
}
```

### HashTable

### Properties

```java
Properties pros=new Properties();
FileInputStream fis=new FileInputStream("jdbc.properties");
pros.load(fis);
String name=pros.getProperty("user");
String password=pros.getProperty("password");
System.out.println(name);
System.out.println(password);
```