# 第三章 Java语法基础

[TOC]

## 3.1 注释

* 注释：就是对代码的解释和说明。为了让人们更加轻松地了解代码。
* 给代码添加注释，是必要且有意义的，而且它也不会影响程序的编译和执行
* **注释与代码要对应，代码修改后，注释也要相应地修改**
* java注释分为3种，`单行注释`、`多行注释`、`文档注释`

### 单行注释

* 单行注释以`//`开头，以`换行`结束，也就是说在`//`后面的内容都算作是注释，不会被编译执行，一直到该行结束，进行了换行。见名知意，单行注释，在一行的最开头输入`//`，就会使得当前的该行不起作用，它成了注释中解释说明的语句

```java
//这是一条单行注释
```

### 多行注释

* 多行注释以`/*`开头，以`*/`结束，见名知意，也就是说，它可以换行注释，直到遇到`*/`结束
* 多行注释不能嵌套

```java
/* 多行注释
这是多行注释
多行注释*/
```

### 文档注释

* 在开始的 /** 之后，第一行或几行是关于类、变量和方法的主要描述。

* 可以包含一个或多个各种各样的 @ 标签。每一个 @ 标签必须在一个新行的开始或者在一行的开始紧跟星号(*).

* 多个相同类型的标签应该放成一组。例如，如果你有三个 @see 标签，可以将它们一个接一个的放在一起

* 注释允许你在程序中嵌入关于程序的信息。你可以使用 `javadoc 源代码文件名.java` 工具软件来生成信息，并输出到HTML文件中

  ```java
  /** 这是文档注释
   * @author agile
   * @version 1.2
   */
  ```

  javadoc 工具软件识别以下标签：

| 标签          | 描述                                                   | 示例                                                            |
| :------------ | :----------------------------------------------------- | :-------------------------------------------------------------- |
| @author       | 标识一个类的作者                                       | @author description                                             |
| @deprecated   | 指名一个过期的类或成员                                 | @deprecated description                                         |
| {@docRoot}    | 指明当前文档根目录的路径                               | Directory Path                                                  |
| @exception    | 标志一个类抛出的异常                                   | @exception exception-name explanation                           |
| {@inheritDoc} | 从直接父类继承的注释                                   | Inherits a comment from the immediate surperclass.              |
| {@link}       | 插入一个到另一个主题的链接                             | {@link name text}                                               |
| {@linkplain}  | 插入一个到另一个主题的链接，但是该链接显示纯文本字体   | Inserts an in-line link to another topic.                       |
| @param        | 说明一个方法的参数                                     | @param parameter-name explanation                               |
| @return       | 说明返回值类型                                         | @return explanation                                             |
| @see          | 指定一个到另一个主题的链接                             | @see anchor                                                     |
| @serial       | 说明一个序列化属性                                     | @serial description                                             |
| @serialData   | 说明通过writeObject( ) 和 writeExternal( )方法写的数据 | @serialData description                                         |
| @serialField  | 说明一个ObjectStreamField组件                          | @serialField name type description                              |
| @since        | 标记当引入一个特定的变化时                             | @since release                                                  |
| @throws       | 和 @exception标签一样.                                 | The @throws tag has the same meaning as the @exception tag.     |
| {@value}      | 显示常量的值，该常量必须是static属性。                 | Displays the value of a constant, which must be a static field. |
| @version      | 指定类的版本                                           | @version info                                                   |

## 3.2 关键字

* 定义：被java语言赋予了特殊含义，用作专门用途的字符串(单词)

* 特点：关键字中的字母全是小写

* 个数：50+3(3个特殊值)+2(两个保留字)

* 关键字分类：

| 用于定义数据类型的关键字           |            |        |            |          |
| ---------------------------------- | ---------- | ------ | ---------- | -------- |
| class                              | interface  | enum   | byte       | short    |
| int                                | long       | float  | double     | char     |
| boolean                            |
| **用于定义流程控制的关键字**       |            |        |            |          |
| if                                 | else       | switch | case       | default  |
| while                              | do         | for    | break      | continue |
| return                             | instanceof |        |            |          |
| **用于定义访问权限修饰符的关键字** |            |        |            |          |
| private                            | protected  | public |            |          |
| **错误处理**                       |
| try                                | catch      | throw  | throws     |          |
| **包相关**                         |
| package                            | import     |        |            |          |
| **类方法变量修饰符**               |
| abstract                           | extends    | final  | implements | volaile  |
| interface                          | native     | new    | static     | strictfp |
| synchronized                       | transient  |
| **变量引用**                       |
| void                               | this       | super  |            |          |
| **保留字**                         |
| goto                               | const      |        |            |          |
| **特殊值**                         |
| true                               | false      | null   |            |          |  |

基本数据类型：byte,short,int,long,float,double,char,boolean
流程控制语句：if,else,switch,case,default,while,for,do,break,continue,return
声明类：class
创建对象：new
权限修饰：public,protected,private
返回值：void
特殊值：true,false,null
包：import,package

## 3.3 保留字

* java保留字，现在没有用，但是以后的版本可能会用，goto、const

* 特殊值：true,flase,null

## 3.4 标识符

* java对各种变量、方法和类，包等要素命名时使用的字符序列称为标识符

* 技巧：凡是自己可以取名字的地方都是标识符

* 标识符：变量名、常量名、方法名、类名、接口名、包名......

### 标识符合法的规则

1. 由26个英文字母大小写，0-9，_或$组成

2. 数字不能作为开头

3. 不能使用关键字、保留字和特殊值(true,false,null)，但能包括关键字、保留字和特殊值

4. java中严格区分大小写，长度无限制

5. 标识符不能包括空格

### java中的名词命名规范

* **包名**：多单词组成时所有字母都小写，如xxx.yyy.zzz

* **类名、接口名**：多单词组成时，所有单词的首字母大写，如XxxYyyZzz

* **变量名、方法名**：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写，如xxxYyyZzz

* **常量名**：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ

* 取名要和实际作用想符合，即“见名知意”

* java采用unicode字符集，因此标识符也可以使用汉字声明，但是不建议使用。

> 如果不遵守该规范，也会编译通过，但是这是业界约定俗成的规范。

## 3.5 数据类型

### 分类

1. 基本数据类型（8种）
   * 整数：`byte`,`short`,`int`,`long`
   * 浮点数：`float`,`double`
   * 单字符：`char`
   * 布尔型：`boolean`
2. 引用数据类型(3大类)
   类`class`，接口`interface`，数组`[]`

> String是引用数据类型，属于一个类

## 3.6 常量

* 定义：不能修改值的量
* 常量的种类
  1. 字面常量：如`1`,`017`,`0xA1F`,`0.1`,`0.2f`,`"ac"`,`'a'`,`"中"`,`true`、`1.2e3`
  2. 用final声明的特殊变量,用此关键字修饰的变量，在声明赋值后不可改变其值
     格式：`final int MAX_NUMBER=999;`

* 字面常量中的浮点数常量默认是double类型的常量，如果要表示float类型常量，必须显式表示，如`1.2f`,`1.2F`

* 字面常量中的byte,short,char型数常量,在两个进行运算时，默认会转成int型的常量，因为它们这些数据类型没有运算法，只能转换成int型
* 如果要表示long类型常量，必须显式表示，如`100L`,`100l`

### 字面常量

1. 整型常量
2. 浮点型常量：`1.3L`、`1.34e3`
3. 字符常量：`'a'`
4. 字符串常量：`"abcc"`

## 3.7 变量

### 变量的概念

* 内存中的一个存储区域

* 该区域的数据可以在同一类型范围内不断变化

* 变量是程序中最基本的存储单元，包含变量类型、变量名、存储的值

* 变量的声明/定义(用来告诉这个变量用来存什么)
  格式：`数据类型 变量名;`

* 变量的赋值：
  格式：`变量名 = 变量值;`
  或者在声明的同时初始化赋值,格式为:`数据类型 变量名= 变量值;`

### 变量的作用

* 用于在内存中保存数据

### 使用变量注意

* java中的变量必须先声明，后使用

* 使用变量名来访问这块区域的值

* 变量有它的作用域，其定于所在的一对{}代码块内

* 变量只有在作用域内才有效

* 同一个作用域内，不能定义重复的变量

* java定义变量类型是强类型的，相对的js是弱类型的语言

### 变量的使用

* java定义变量的格式：数据类型 变量名 = 变量值；

* 成员变量声明之后可以不初始化也能直接使用，因为系统使用默认初始值；但是局部变量，必须初始化后才能使用，否则会抛出异常

## 3.8 输出

```java
System.out.println();//可以编译，输出一个空行，光标移到下一行
System.out.print();//不能编译，会抛出异常，找不到该方法
```

也就是说，`println`的同名方法中有支持不传入参数的方法，而`print`的同名方法中没有支持，故会报错找不到方法

## 3.9 进制

> 计算机中存储和运算的所有数据全都要转为二进制，包括数字、字符、图片、音频、视频

* 二进制（binary）:0，1；满2进1，以0b或者0B开头

* 十进制（decimal）:0-9;满10进1

* 八进制（octal）:0-7；满8进1，以数字0开头

* 十六进制（hex）:0-9及A-F，满16进1，以0x或0X开头表示。此处的A-F不区分大小写

* 所有数字在计算机底层都以二进制形式存在

* 二进制数据的存储方式：不管正负，都以补码方式存储

### 原码、反码、补码

> 二进制数据有原码、反码、补码这三种表示形式
> 只有补码可以正确的表示正负数，且不重复，所以**补码才是计算机中二进制数据的存储的方式**

### 机器数

一个数在计算机中的二进制表示形式,  叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为0, 负数为1.

比如，十进制中的数 +3 ，计算机字长为8位，转换成二进制就是00000011。如果是 -3 ，就是 10000011 。

那么，这里的 00000011 和 10000011 就是机器数。

### 真值

因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 10000011，其最高位1代表负，其真正数值是 -3 而不是形式值131（10000011转换成十进制等于131）。

所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。例：0000 0001的真值 = +000 0001 = +1，1000 0001的真值 = –000 0001 = –1

### 原码

原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:

```text
[+1]原 = 0000 0001

[-1]原 = 1000 0001
```

第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:

```text
[1111 1111 , 0111 1111]==>[-127 , 127]
```

### 反码

反码的表示方法是:

* 正数的反码是其本身

* 负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.

```text
[+1] = [00000001]原 = [00000001]反
[-1] = [10000001]原 = [11111110]反
```

### 补码

补码的表示方法是:

* 正数的补码就是其本身

* 负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)

```text
[+1] = [00000001]原 = [00000001]反 = [00000001]补

[-1] = [10000001]原 = [11111110]反 = [11111111]补
```

扩展：[为何要使用原码，反码和补码](./原码反码补码.md)

## 3.10 变量分类

### 按照变量的数据类型分类

> 每种数据都定义了明确的具体数据类型(强类型语言)，在内存中分配了不同的大小的内存空间

![Java基本数据类型](../images/基本数据类型.png "Java基本数据类型")
> byte读作bai te

### 按照变量的声明位置分类

![Java变量分类按位置](../images/变量分类按位置.png "Java变量分类按位置")

> 相同点：成员变量和局部变量都有生命周期
> 不同点：局部变量除形参外，需显式初始化

### 易错点

* byte与Byte
* int 与Integer
* short与Short
* long与Long
* double与Double
* float与Float

> 以上它们是同一个数据类型吗？数据范围是否相同？
> 答：它们不是相同的数据类型，大写的那些是Java自己封装的一些类，封装了一些工具函数，供开发时使用

### 整型类型

* java各数据类型有固定的表数范围和字段长度，不受具体OS的影响，以确保java程序的可移植性

* java的整型常量默认为int类型，声明long型常量须后加l或L

* java程序中一般变量为int，除非不足以表示较大的数，才使用long

| 类型  | 占用存储空间 | 表数范围                |
| ----- | ------------ | ----------------------- |
| byte  | 1字节        | -128\~127`（-2^10~2^8-1）` |
| short | 2字节        | `-2^15~2^15-1`            |
| int   | 4字节        | `-2^31~2^31-1`            |
| long  | 8字节        | `-2^63~2^63-1`            |

> bit是计算机中最小的存储单位，byte是计算机中基本的存储单元



### 浮点类型

* float：单精度，尾数可以精确到7位有效数字

* double:双精度，精度是float两倍

* Java的浮点型常量默认为double型，声明float型常量，须后加f或F，如1.2f

* 科学计数法的格式：`底数e指数`,其中底数为-10<底数<10的小数，指数为不为0的整数

* 科学计数法表示的浮点数常量默认为double类型

  ```java
  double d=1.2;
  float f=13.3F;//这里的F不可省略
  double d2=1.2e4;//这里是科学计数法表示的浮点数
  float f2=1.2e4f;//指定浮点数为float类型常量
  ```

| 类型         | 占用存储空间 | 表数范围             |
| ------------ | ------------ | -------------------- |
| 单精度float  | 4字节        | -3.403E38~3.403E38   |
| 双精度double | 8字节        | -1.798E308~1.798E308 |

> **float表示数据的方式不是像整型那样每一位表示一个数字然后为2的阶乘那么简单，使用了新的约定存储方式，所以float表示的数字范围比整型中的long还要大**

扩展：[浮点类型数据的存储原理](./浮点类型数据的存储原理.md)

### char类型

* 字符char占用的存储空间，1个字符=2字节

* 定义char型变量，使用一对`''`,即单引号，内部只能写一个字符

```java
char ch='1';
char ch2='中';
```

```java
char ch=97;//char='a';
int i='a';//i=97;
```

* 字符可以几种表示方式：
  1. 是直接的一个字符，如`'a'`,
  2. 是转义字符,如换行符`'\n'`，它是用两个字符表示一个字符，因为进行了转义，又如制表符`'\t'`
  3. 直接使用Unicode值来表示字符型常量，如`'\u0043'`

* 常见的转义字符

```java
\n：换行
\r：回车,但是光标并不会下移到下一行,还是停留在原位置
\t：Tab键,光标会右移到第6个字母
\\：\
\"："
\'：'
\b：删除键Backspace，光标会回退一个光标
```

```java
char ch1='a';
char ch2='\t';
char ch3='\u0043';
char ch='\32';//这是一个空字符，因为它在ASCII表里的序号是32
```

扩展： [字符编码](./字符编码.md)

## 3.11 类型转换

### 自动类型提升

> 自动类型提升指的是基本数据类型之间的自动类型提升

* byte->short->int->long->float->long  它们之间两种不同类型的变量相加，会朝着这个顺序提升

* 当容量小的与容量大的做运算时，结果自动提升为容量大的数据类型

* 此时值的容量大小不是说数据类型在内存中所占存储的大小，而是说它能表示的数据范围的大小，如long数据类型占8个字节，而float只占4个字节，但是它们两个相加，结果会提升为float类型

* byte、short、int中的一个与char进行运算，结果只能至少是int类型

* byte、short、char->int->long->float->double
  byte与byte、short与short、char与char，或者它们混合进行运算后，结果不是原类型，因为java将它们转成了int，所以得用int类型来接收(这些类型没有对应的运算，它们被转成了int，所以结果是int类型)
  >但是char与char的常量进行运算是不会提升的

```java
byte b1=1;
byte b2=2;
byte b3=b1+b2;//这个会报错，右边结果应该用int接收

byte b4='A'+'0';//这个可以编译通过,原因：右边两个是常量，我们说的变量自动提升指的都是变量，常量不会

char ch='A'+2;//编译通过，常量之间没有提升的说法

char a='A';
int n=2;
char ch1=a+n;//编译不通过，因为右边为int，所以需要强转
```

### 强制类型转换

* 这个强制类型转换是自动类型提升的逆运算

* 这是将存储范围大的值赋值给存储范围小的变量时，进行的操作

* 需要使用强转符号：`(需要转换到的数据类型)`

* 强制类型转换可能导致精度损失

```java
double d=12.3;
int var1=(int)d;
```

* 原本的大数据范围的变量转换成小范围的数据，可能会得到意想不到的数据，因为数据已经超过了它的数据范围，就会在范围内偏移

```java
int i=128;
byte b=(byte)i;
System.out.println(b);//打印结果为-128；因为byte表示的数据范围为-128~127
```

* 两个注意

```text
long l=12345;//这里long型常量没有写L，但也正确，那是因为12345是int型常量，随后赋值时会被自动提升为long型
float f=12.3;//这里会报错，因为12.3是double型常量，随后赋值给float型变量，会抛出异常，double不会自动提升到float
float f1=(float)12.3;//需要强制类型转换才能编译通过，或者指定浮点常量是float类型，即12.3F
```

## 3.12 String类型

* String是引用型数据类型

* String类型的变量被赋值时，使用的是一对双引号`""`

* String类型的数据可有0个或者1个以上(包括1个)char类型的字符，即`"123中"`

* char类型的数据不能有0个字符，char类型变量有且仅有一个字符

```java
char ch='';//编译不通过，会报错
String s="";//编译通过
```

* String可以与8种基本数据类型的变量进行连接运算：+

```java
int number=1001;
String s="学号：";
String info=s+number;//info为"学号：1001"
String info1=number+s;//info1为"1001学号为："
```

* 多个不同的数据类型变量进行+运算，只要其中一个变量时String类型，结果则为String类型

```java
System.out.println('1'+'2');//控制台并不会输出12，而是99，因为这两个都是char类型，不是String类型，不会连接运算
```

```java
String str=4;//报错
String str2=3.5f+"";//str2="3.5";

short s=5;
s=s-2;//报错，因为2是int型常量，右边结果为int型，s却为short型，需要强制转换

byte b=3;
b=b+4;//抛出异常
b=(byte)(b+4);//编译通过

float d=.314F;//编译通过，小数点前面为空则表示为0

byte b=5;
short s=3;
short t=s+b;//抛出异常，s+b为int型变量，需要强制转换
```

* boolean类型转换成String类型，则为"true"或者”false”

* String类型与整型进行互相转换，需要使用包装类来进行

```java
String s="1234567";
int i=Integer.parseInt(s);
String s1=String.valueOf(i);
```

## 3.13 运算符

运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等
运算符可以分类为：

* 算术运算符

* 赋值运算符

* 比较运算符（关系运算符）

* 逻辑运算符

* 位运算符

* 三元运算符

### 3.13.1 算术运算符

算术运算符列表
| 运算符 | 运算                     | 范例       | 结果    |
| ------ | ------------------------ | ---------- | ------- |
| +      | 正号                     | +3         | 3       |
| -      | 负号                     | b=4;-b     | -4      |
| +      | 加                       | 5+5        | 10      |
| -      | 减                       | 6-4        | 2       |
| *      | 乘                       | 3\*4       | 12      |
| /      | 除                       | 5/5        | 1       |
| %      | 取模（取余）             | 7%5        | 2       |
| ++     | 自增（前）：先自增后取值 | a=2;b=++a; | 3       |
| ++     | 自增（后）：先取值后自增 | a=2;b=a++; | 2       |
| --     | 自减（前）：先自减后取值 | a=2;b=--a; | 1       |
| --     | 自减（后）：先取值后自减 | a=2;b=a--; | 2       |
| +      | 字符串连接               | "He"+"llo" | "Hello" |

#### 除`/`

* 整数除以整数结果还是整数，小数点部分被略掉

```java
System.out.println(1.0/0.0);//输出Infinity
System.out.println(1/0.0);//输出Infinity
System.out.println(1/0);//报错
```

#### 取余运算`%`

* 格式：`被模数 % 模数 = 结果`

* **结果的符号与被模数的符号相同**

#### 正号`+`

```java
int i=3;
int j=-i;//j=-3
int k=+j;//k=-3,变量为负数时，前面使用正号运算符，结果不会取反
int h=-k;//h=3,负负得正，负号在变量前面时，会取相反数
```

#### 自增、自减

* 自加、自减符号在数据的前后位置不同，可能导致参与运算得到的值不同，根本原因是自增、自减运算优先级低于赋值运算符，放在前面则就只能先进行算术运算后赋值

* 自增1，自减1不会改变本身变量的数据类型，如:

```java
byte b=127;//byte b=128会报错，超出范围
b++;//此时b=-128,编译通过
b=b+1;//报错，无法编译通过;如果b=12,b=b+1也是无法通过的，1为int型常量
```

* 不能连续自增或者自减

```java
int i=3;
i++++;//编译不通过
(i++)++;//编译不通过
```

* i=i++
  有如下代码：

  ```java
  public class Exam1 {
    public static void main(String[] args) {
        int i = 88;
        i = i++;
        //执行后，i=88
    }
  }
  ```

  可以这样理解：`i=i++;`在执行时，有类似这样的过程：

  ```java
  temp=i;
  i=i+1;
  i=temp;//这里左边是i,temp是存着原先i的值
  ```

  而`i=++i;`过程是这样的:

  ```java
  i=i+1;
  temp=i;
  i=temp;
  ```

  所以，`j=i++;`和`i=i++;`虽然都遵循`先赋值后自增`得到的结果却不相同。`j=i++;`与上面相同的过程，如下：

  ```java
  temp=i;
  i=i+1;
  j=temp;//这里左边是j,temp是存着原先i的值，所以j=i[原]
  ```

 >也可以在从编译器底层的编译原理来看这个过程的原理，这里需要一个`javap命令`来反编译class文件，可以得知它的编译过程

```text
$ javap -c Exam1
Compiled from "Exam1.java"
public class Exam1 {
  public Exam1();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return

  public static void main(java.lang.String[]);
    Code:
       0: bipush        88
       2: istore_1
       3: iload_1
       4: iinc          1, 1
       7: istore_1
       8: return
}
```

```text
bipush 将局部的常量入栈到操作数栈
istorre_1 将操作数栈中的第一个数取出来  ,这里也就是将88赋值给变量i
iload_1 将局部的变量中的第一个变量值存入到操作数栈中，也就是因为要执行i++，于是把i的值放入了操作栈里了
iinc 将第一个局部变量自加1    也就是将i自加
istore_1 将操作数栈中的第一个数取出来   ，也就是说把第三步中放进去的数取出来了，赋给了变量i
```

 > 当然，不同的语言，底层实现这个++、--制定的规则不同，c语言就不是这样

### 3.13.2 赋值运算符

* 赋值运算符有 `=`、`+=`、`-=`、`*=`、`/=`、`%=`

* 支持连续赋值

* 赋值运算符的优先级最低

* 赋值运算符的左边一定是一个变量,且左边变量的类型>=右边的值或者结果的类型，不然就需要进行强制类型转换

* 扩展的赋值运算符，比如`a+=x+3`，右边应当作是一个整体

```java
int i1=10；
int j1=10;

int i2,j2;
i2=j2=10;

int i3=10,j3=10;

//以上三种的效果是相同的
```

```java
int i=3;
i+=2;//编译通过，i=5,此命令与i=i+3;相同

//但是
short s=3;
s=s+2;//编译不通过，会抛出异常；因为2为int型常量
s+=2;//该命令是编译通过，可见这样写不会改变s的数据类型
```

* **+=不会改变变量的数据类型**

```java
int m=5;
m*=0.3;//编译通过，m=1，因为*=不会改变数据类型
```

### 3.13.3 比较运算符

* 比较运算符的结果都是boolean型，也就是true或false

* 比较运算符的"=="不能误写成"="

* 对于基本数据类型，`==`可以直接对值进行比较。但是对于引用数据类型，特别是String类型的字符串进行比较，`==`是去比较变量在内存里的地址是否相同，想比较字面上的字符串是否相同，需要使用字符串String类中的方法`equals`

```java
Scanner sc=new Scanner(System.in);
String s1="abc";
String s3="abc";
String s2=sc.next();//输入字符串：abc
System.out.println(s1==s2);//false
System.out.println(s1==s3);//true
System.out.println(s1=="abc");//true
System.out.println(s2=="abc");//false
System.out.println("s2:"+s2);//s2:abc
System.out.println(s2.equals("abc"));//true
sc.close();
```

> 深度剖析：
  从上面的代码可以看出，虽然s1,s2,s3这三个变量都是放的字符串`"abc"`,但是使用`==`符号得到的结果却不相同，s1和s3是直接在代码里将字符串常量赋值给变量，引用数据类型的变量其实存的是内存地址，所以s1和s3都是指向**常量池**的地址，而s2是局部变量，接收变量，此时s2指向的是**堆**
  //todo,等了解了java底层怎样放数据后再详细说明

| 运算符     | 运算               | 范例                      | 结果  |
| ---------- | ------------------ | ------------------------- | ----- |
| ==         | 相等于             | 4==3                      | false |
| !=         | 不等于             | 4!=3                      | true  |
| <          | 小于               | 4<3                       | false |
| >          | 大于               | 4>3                       | true  |
| <=         | 小于等于           | 4<=3                      | false |
| >=         | 大于等于           | 4>=3                      | true  |
| instanceof | 检查是否是类的对象 | "Hello" instanceof String | true  |

```java
int i=10;
int j=20;
System.out.println(i==j);//控制台输出：false
System.out.println(i=j);//控制台输出：20
```

### 3.13.4 逻辑运算符

`&`：逻辑与

`|`：逻辑或

`!`：逻辑非

`&&`：短路与

`||`：短路或

`^`：逻辑异或

| a     | b     | `a&b` | `a&&b` | `a|b` | `a||b` | `!a`  | `a^b` |
| ----- | ----- | ----- | ------ | ----- | ------ | ----- | ----- |
| true  | true  | true  | true   | true  | true   | false | false |
| true  | false | false | false  | true  | true   | false | true  |
| false | true  | false | false  | true  | true   | true  | true  |
| false | false | false | false  | false | false  | true  | false |

* &与&&区别：

&和&&都可以用作逻辑与的运算符，表示逻辑与（and），当运算符两du边的表达式的结果都为true时，整个运算结果才为true，否则，只要有一方为false，则结果为false。

&&还具有短路的功能，即如果第一个表达式为false，则不再计算第二个表达式，例如，对于`if(str != null && !str.equals(""))`表达式，当str为null时，后面的表达式不会执行，所以不会出现NullPointerException如果将&&改为&，则会抛出NullPointerException异常。`if(x==33 & ++y>0)` y会增长，`if(x==33 && ++y>0)`不会增长

&还可以用作位运算符，当&操作符两边的表达式不是boolean类型时，&表示按位与操作，我们通常使用0x0f来与一个整数进行&运算，来获取该整数的最低4个bit位，例如，0x31 & 0x0f的结果为0x01。

* 异或^:两个运算的数据相同则为false,不同则为true

* &、|、^当两边的表达式结果不是boolean类型，可当成位运算符进行位运算

```java
boolean b1=false;
int num1=10;
if(b1&(num1++ >10)){

}else{

}
System.out.println(num1=+num1);//num1=11


//如果代码如下：
boolean b1=false;
int num1=10;
if(b1&&(num1++ >10)){

}else{

}
System.out.println(num1=+num1);//num1=10
```

* 区别&与&&：

  1. &与&&的运算结果相同

  2. 当符号左边是true时，二者都会执行符号右边的运算
不同：当符号左边是false时，&继续执行符号右边的运算；&&不再执行符号右边的运算

### 3.13.5 位运算符

* 位运算符有下面7个

| 运算符 | 运算       | 范例                          |
| ------ | ---------- | ----------------------------- |
| <<     | 左移       | 3<<2=12    //相当于`3*2*2=12` |
| >>     | 右移       | 3>>1=1      //相当于`3/2=1`   |
| >>>    | 无符号右移 | 3>>>1=1    //相当于`3/2=1`    |
| &      | 与运算     | `6&3=2`                       |
| \|      | 或运算     | `6|3=7`                       |
| ^      | 异或运算   | `6^3=5`                       |
| ~      | 取反运算   | `~6=-7`                       |

![位运算示例](../images/位运算实例.png "位运算示例")

* 位运算是直接对整数的二进制进行的运算

* `<<`:在一定范围内，每向左移1位，相当于*2(这句话不严谨)
       在二进制上面实际的操作：左移把左边的挤掉，右边补0

```java
int num=2;//int型的变量是4字节，占32个bit位
System.out.println(num1<<33);//输出为：4 原因：左移32位后就变回来了原来的数，所以num1<<33与num1<<1结果相同

int num2=2;
System.out.println(a>>33);//输出为：1 原因：右移32位后就变回来了原来的数，所以num1>>33与num1>>1结果相同
```

* `>>`:在一定范围内，每向左移1位，相当于/2;右移时，根据原来的数的最高位是1还是0，则右移后的空位则补上1或者0

* `>>>`:不管最高位是0还是1，右移后空缺位都补0

* `^`：相同二进制位`^`运算，`0^0=0;`,`1^1=0;`不同二进制位`^`运算，`1^0=1;`,`0^1=1`

* ~：所有位，包括符号位，全部取反
  >这里的取反，是基于补码来取反，得到的结果也是补码，要区别数学中的取反。

   ```java
   System.out.println(~3);//控制台输出为：-4
   ```

* 异或`^`运算符的一个定理：`m=(m^n)^n;`

#### 交换两个整数的方法

* 定义临时变量的方式

```java
int num1=1,num2=2;
int temp=num1;
num1=num2;
num2=temp;
```

* 不定义临时变量

```java
int num1=1,num2=2;
num1=num1+num2;
num2=num1-num2;
num1=num1-num2;
```

* 使用位运算符

```java
int num1=23,num2=43;
num1=num1^num2;
num2=num1^num2;
num1=num1^num2;
```

> 从通用上来看，第一种方式最好，因为它不用局限于需要交换的两个变量必须得是整数，对数据类型没有限制

### 3.13.6 三元运算符

* 结构：(条件表达式)？ 表达式1：表达式2；

* 条件表达式的结果为boolean类型，如果结果为true，则执行表达式1，反之结果为false,则执行表达式2

* 表达式1和表达式2要求数据类型是一致的，不一致的话，如果可能，会进行自动变量提升

  ```java
  int i=true? 1:2.0;//编译不通过
  double d=true? 1:2.0;//d=1.0

  Object obj=true? new Integer(1):new Double(2.0);//进行了自动类型提升转换，并进行了拆箱和装箱
  System.out.println(obj);//输出为：1.0
  ```

* 三元运算符是可以嵌套使用的(如果看起来很乱就不要去嵌套)

* 三元运算符的表达式不能单独一个语句

```java
int age=19;
age>=18? "成年":"未成年";//编译不通过，这不是一个语句
String status=age>=18? "成年":"未成年";
```

获取三个数的最大值

```java
int n1=12,n2=30,n3=-43;
int max1=(n1>n2)? n1:n2;
int max2=(max1>n3)? max1:n3;//max2为最大值，不要将这两个三元运算符放在一个式子里，可读性和修改都不容易
```

* 凡是可以使用三元运算符的，一定可以改写成if-else；反之则不一定，if-else判断后的里面可以写很多个代码语句，而三元运算符中的表达式1或者表达式2

### 3.13.7 运算符的优先级

//todo,总结优先级

```java
int r = 1;
int s = r++ + ++r * r++;//s=1+3*3=10
System.out.println("r=" + r + ";s=" + s);// r=4;s=10
```

* 计算的时候确实是先乘除后加减，但是，在处理的时候是从左到右去扫描,扫描的时候如果有一元运算符`++`、`--`则会进行运算，不过取值还是根据运算符的特性进行

## 3.14 流程控制

* 流程？
  （1）按照什么顺序做事情
  （2）有选择
  （3）是否重复

* 流程控制语句
  用来控制**程序中各语句执行顺序**的语句，可以把语句组成能完成一定功能的小逻辑模块。

* 流程控制方式采用结构化程序设计中规定的三种基本流程结构，即：

  `顺序结构`、`分支结构`、`循环结构`

* 顺序结构：就是代码从上往下执行，没有任何判断和跳转

* 分支结构：根据条件，选择性的执行某段代码，有if-else和switch-case两种分支语句

* 循环结构：根据循环条件，重复性的执行某段代码，有while、do……while、for三种循环语句

> 注：JDK1.5提供了foreach循环，方便进行集合遍历、数组元素

### 3.14.1 分支结构

#### if-else

* else 结构是可选的

* 针对于条件表达式：

  1. 如果多个条件表达式之间是”互斥“关系（或者没有交集关系），哪个判断和执行语句声明在上面或者下面，无所谓

  2. 如果多个条件表达式之间有交集，需要根据实际情况来考虑

  3. 如果多个条件表达式之间有包含的关系，通常将范围小的条件表达式放在上面，优先判断

* 如果if-else结构中的执行语句只有一行时，对应的一对{}可以省略，但是规范上来说不建议省略

* if-else结构是支持相互嵌套的

* **else遵循就近原则，如果没有{}来规定else对应的if，则就近匹配**

```java
int x=4;
int y=1;
if(x>2)
  if(y>2)
    System.out.println(x+y);
else
  System.out.println("x is "+x);//就近原则，这个else匹配的是第4行的if(y>2)
```

#### switch-case

* 格式

```java
switch(表达式){
  case 常量1:
    执行语句1;
    break;//不写的话就会执行下面所有的语句，且不检查,直到遇到break才会停止；如果可能，也可以执行default里面的语句
  case 常量2:
    执行语句2;
    break;
  default:
    执行语句n;
    break;//写不写已经无所谓了，在这里
}
```

* 根据switch表达式中的值，一次匹配各个case中的常量。一旦匹配成功，则进入相应case结构中，调用其执行语句；当执行语句后，仍然继续向下执行，直到遇到break关键字或此switch-case结构末尾才结束。

* break可以在switch-case结构中使用，跳出switch-case结构。

* switch结构中的表达式，只能是如下6中：byte、short、int、枚举类型(JDK5.0新增)、char、String类型(JDK7.0新增)

> 也就是说没有long、boolean类型，double、float等类型

* case位置只能写常量，不能写变量，更不能写表达式，也不能写boolean 类型

* default是可选的，而且位置没有要求，不一定必须放在最后，放在switch里面任何位置都可以，没有先后之分
  > 此处说default没有位置之分，指的是在没有匹配的case情况下，如果已经匹配上了一个case，且没有break，那么有可能执行switch里面的default。
  但是，假如这个default的位置在刚刚匹配的case上面，那么此时的default不会被执行，如下示例

```java
char ch='a';
switch(ch){
    default:
        System.out.print('d');
    case 'a':
        System.out.print('a');
    case 'b':
        System.out.print('b');
    case 'c':
        System.out.print('c');
    //控制台最后会输出abc

switch(ch){
    case 'a':
        System.out.print('a');
    case 'b':
        System.out.print('b');
    case 'c':
        System.out.print('c');
    default:
        System.out.print('d');
    //控制台最后会输出abcd
}
```

### 3.14.2 循环结构

* 循环的种类

  `for`、`while`、`do……while`

* 循环语句的四个组成部分

  * ①初始化部分

  * ②循环条件部分：boolean类型

  * ③循环体部分

  * ④迭代部分

![循环结构图解](../images/循环组成图解.png "循环结构图解")

#### for循环

* 格式

```java
for(初始化部分;循环条件;迭代部分){
  循环体部分
}
其他语句
```

```java
for(①;②;④){
  ③
}
```

执行过程：①->②->③->④->②->③->④->......->②    ，直到②为false时就停止了循环

* break也可在for循环中使用，用来跳出循环

* 循环结束的方式
  * 循环条件部分返回false
  * 在循环体中，执行break
  * 在循环体中，执行了return

#### while循环

* 格式

```java
初始化部分
while(循环条件部分){
  循环体部分
  迭代部分
}
```

* while循环不能忘记了迭代条件，否则会是死循环

* 写程序要避免出现死循环，无论出现什么情况，都要考虑到，要能使得循环停下来

* for循环和while循环，它们执行循环的四个部分的顺序时相同的，也就表明for循环一定可以与while循环互相转换写法

* 区别：for循环的初始化条件在循环体内，如果在初始化时定义变量，则循环体外不能再使用该变量，而while循环的初始化部分在循环体外面，所以循环体外仍可使用该变量

* while循环和for循环细微使用差异
  * 一般来说，当循环次数比较明显，从m循环到n次，一般考虑for循环更多
  * 当循环次数不明显，但是我们明确知道循环的条件时，可以考虑使用while循环

#### do-while循环

```java
初始化部分
do{
  循环体部分
  迭代部分
}while(循环条件);
```

执行过程：①->③->④->②->③->④->②->......->③->④->②

* do-while循环至少可以执行一次循环体和迭代部分

* 如果循环体可以执行多次的时候，do……while循环和while循环效果是一样的，但是当可能会出现循环条件一开始就为false的情况下，则结果不同，do……while循环会执行一次，而while循环则一次也不执行

* 开发中，for循环和while循环的使用比do……while循环的使用多

* 当循环体语句块需要至少执行一次，那么考虑使用do-while
  换言之，for循环和while循环的循环体语句是有可能一次都不执行的

* 循环体部分和迭代部分定义的变量在循环条件内无法使用，因为局部变量的范围是在一对`{}`内

  ```java
  Scanner scanner=new Scanner(System.in);
  do{
      int num=scanner.nextInt();
  }while(num!=0);//无法编译通过，num是do里面的局部变量
  ```

#### 嵌套循环

* 内层循环结构遍历一遍，只相当于外层循环体执行了一次

* 假设外层循环体执行了m次，内层循环体执行了n次，此时内层循环体一共执行了m*n次

### 3.14.3 break和continue

* break
  结束当前循环，关键字后面不能声明执行语句
  **多层循环体中，break只跳出当层的循环，即一层**

* continue
  结束当次循环，关键字后面不能声明执行语句

## 3.15 简单的控制台输入输出

### 3.15.1 输出

#### println

* 会在输出后打印一个`\n`,光标移动到下一行

#### print

* 输出后不会移动光标换行

#### printf

* %d：十进制整数
* %f：浮点数
* %c：单个字符
* %b：boolean值
* %s：字符串

> printf方法十分类似C语言的输出风格，如下示例：

```java
int a=1;
double d=2.3;
String s="1111aa";
char ch='a';
System.out.printf("%d %f %s %c",a,d,s,ch);
//1 2.300000 1111aa a
```

### 3.15.2 输入

```java
Scanner scanner=new Scanner(System.in);
System.out.print("请输入您的姓名：");
String username=scanner.next();
System.out.print("请输入您的年龄：");
int age=scanner.nextInt();
System.out.print("请输入您的体重：");
double weight=scanner.nextDouble();
System.out.println("是否已婚：");
boolean isMarried=scanner.nextBoolean();
System.out.println("您的个人信息是：");
System.out.println("姓名："+username);
System.out.println("年龄："+age);
System.out.println("体重："+weight);
System.out.println("是否已婚："+isMarried);
scanner.close();


//Scanner没有提供获取char型数据的方法，只能提供获取一个字符串的方式来存
String gender_str=scanner.next();
char gender_ch=gender_str.charAt(0);
```

* 如果输入的数据类型与要求的类型不匹配会抛出异常(无法提升的变量)，比如要求输入整型数字，却输入了字符串

* next()与nextLine()区别
  1. next()方法：遇到空格等空白符，就认为输入结束
  2. nextLine()方法：遇到回车换行，就认为输入结束

```java
Scanner sc=new Scanner(System.in);
String next=sc.next();//当在命令行窗口输入为：aaabb  cccc
System.out.println(next);//打印的结果为：aaabb
sc.close();
```
