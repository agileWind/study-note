# Java浮点数的存储原理

## Java浮点数标准

* java中浮点数采用的IEEE754标准，该标准的全称为IEEE二进制浮点数算术标准。这个标准规定的存储格式是这样的：**符号位+指数位偏移+尾数位**

![存储格式](../images/存储格式.webp "存储格式")

* IEEE 754常用的两种表示浮点数值的方式：单精确度（float 32位）、双精确度（double 64位）

![浮点数存储格式](../images/浮点数存储格式.webp "浮点数存储格式")

* 浮点数表示的数值：`V = (-1)^s × M × 2^E`
* 符号(sign) ：1个bit表示，当s=0，V为正数；当s=1，V为负数。
* 阶码(exponent) ：E的作用是对浮点数加权，用于存储科学计数法中的指数数据，并且采用移位存储。float类型的阶码是 8 bits，double类型的阶码是 11 bits。
* 尾数(significand) ：M是一个二进制小数，因为是二进制，所以科学计数法中这个值范围是：1≤M<2。(和十进制中范围为1~10一样)
        IEEE 754对有效数字M和指数E，还有一些特别规定。前面说过，1≤M<2，也就是说，M可以写成1.xxxxxx的形式，其中xxxxxx表示小数部分。IEEE 754**规定，在计算机内部保存 M时，默认这个数的第一位总是1，因此可以被舍去，只保存后面的xxxxxx部分**。比如保存1.01的时候，只保存01，等到读取的时候，再把第一位的1加上去。这样做的目的，是节省1位有效数字。以32位float浮点数为例，留给M只有23位，将第一位的1舍去以后，等于可以保存24位有效数字。 道理就是在这里，那 24bit 能精确到小数点后几位呢，我们知道 9 的二进制表示为 1001，所以 4bit 能精确十进制中的 1 位小数点， 24bit 就能使 float 能精确到小数点后 6 位。
        至于指数E，情况就比较复杂。 首先，E为一个无符号整数（unsigned int）这意味着，如果E为8位 (float类型) ，它的取值范围为0~255；如果E为11位（double类型），它的取值范围 为0~2047。但是，我们知道，科学计数法中的E是可以出现负数的（因为0.75用科学计数法表示就是1.1*2^-1），所以 IEEE 754**规定，存入内存时E的真实值必须再加上一个中间数，对于8位的E，这个中间数是127；对于11位的E，这个中间数是1023**。比如，2^10的E是10，所以保存成32位浮点数时，必须保存成10+127=137，即10001001。

## 浮点数转二进制数

### 能精确表示的浮点数

哪些小数能被精确表示呢？0.5的倍数，且在精度以内。
方便计算，首先选择可以用浮点数**精确**表示的数计算：4.25

-step1.**首先将数字转为2进制：**
整数部分4： "除2取余"
4/2=2 余 0
2/2=1 余 0
1/2=0 余 1

小数部分0.25：**"乘2取整"**
`0.25 * 2 = 0.5` 未进位 0
`0.50 * 2 = 1` 进位整数 1
二进制表示：100.01

step2.**将二进制数转为科学计数法表示**
科学记数法表示：`1.0001 * 2^2`

step3.转换为IEEE754格式存储
符号位 0 （正数0 负数1）
指数 2 （float指数+127=127 double指数+1023=1025）
尾数 0001

单精度float:符号位0     指数位129(10000001)     尾数001
0 10000001 00010000000000000000000

双精度double:符号位0 指数位1025(10000000001) 尾数001
0 10000000001 0001000000000000000000000000000000000000000000000000

### 不能精确表示的浮点数

举个例子：1/3，十进制就无法精确表示三分之一这个数字。

二进制也有很多很多小数无法精确表示，包括：0.1和0.2，这也是导致计算出现精度问题的根本原因。

下面将0.1转为2进制表示。

0.1
step1.**首先将数字转为2进制：**
`0.10 * 2 = 0.20` 未进位 0
`0.20 * 2 = 0.40` 未进位 0
`0.40 * 2 = 0.80` 未进位 0
`0.80 * 2 = 1.60` 进位 1
`0.60 * 2 = 1.20` 进位 1
`0.20 * 2 = 0.40` 未进位 0
`0.40 * 2 = 0.80` 未进位 0
`0.80 * 2 = 1.60` 进位 1
`0.60 * 2 = 1.20` 进位 1
无限循环（0011）...

二进制表示0.1:
0.00011001100110011001100110011001100110011001100110011001...

step2.**将二进制数转为科学计数法表示**
科学记数表示：
1.1001100110011001100110011001100110011001100110011001... * 2^-4

step3.**转换为IEEE754格式存储**
符号位 0 （正数0 负数1）
指数 -4 （float指数+127 double指数+1023）
尾数 1001100110011001100110011001100110011001100110011001...

float 单精度浮点数，尾数只能存储23位，多余位数四舍五入:
0 01111011 10011001100110011001101

double 双精度浮点数，尾数只能存储52位，多余位数四舍五入:
0 01111111011 1001100110011001100110011001100110011001100110011010
