# 第五章 异常

## 5.1 异常概述与异常体系

* 异常：在Java语言中，将程序执行中发生的不正常情况称为“异常”。(开发过程中的语法错误和逻辑错误不是异常)

* Java程序在执行中所发生的异常事件可分两类：
  * Error:Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。比如：StackOverflowError和OutOfOMemoryError。一般不编写针对性的代码进行处理
  * Exception：其他因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理，如：
    1. 空指针访问
    2. 试图读取不存在的文件
    3. 网络连接中断
    4. 数组角标越界
  ![异常类型分类图示](./../images/异常类型分类图示.png)

  >1. 从图示可知，Excpetion类型的异常中，除子类异常中的运行时异常RuntimeException外，其他的任何异常都不是运行时异常，同时，这些非运行时异常需要在编译时解决，也就是说非运行时异常必须处理，才可编译通过，所以又称非运行时异常为受检异常
  >2. 可以通过IDE的快捷键(IDEA:Ctrl+H;Eclipse:Ctrl+T)查看某个类的父子类继承的所有情况.通过该方法可以查看到所有继承Exception类的子类，可以看到子类中除去RuntimeException类外，其他的都是受检异常，当然也可以查看所有继承了运行时异常RuntimeException的子类，即已有的运行时异常的子类

* 对于错误，有两种解决方法：
  1. 遇到错误就终止程序的运行
  2. 程序员在编写程序时，就考虑到错误的检测、错误消息的提示、以及错误的处理

* 对于错误，分为编译错误，和运行时错误
  1. 编译错误，编写的代码有问题，就需要修改代码去解决
  2. 运行时发生的错误，仅仅是编写代码是解决不了的，就需要我们预考虑到，然后捕获到异常后再处理，以此保证整个程序不会终止

## 5.2 异常处理

异常处理方式：
try-catch-finally
throws+异常类型：向上抛出异常，让调用者去处理

异常的处理：抓抛模型

过程一：“抛”，程序在正常执行过程中，一旦出现异常，就会在异常代码处生成一个对应异常类的对象，并将此对象抛出，一旦抛出对象以后，其后的代码就不再执行

过程二：“抓”，可以理解为异常的处理方式：

1. try-catch-finally
2. throws

```text
try{
    //可能出现异常的地方
}catch(异常类型1 变量1){
    //处理方式3
}finally{
    //一定会执行的代码
}
```

```java
String str="abc";
try{
    int num=Integer.parseInt(str);
    System.out.println("hello-1");
}catch(NumberFormatException e){
    //
    System.out.println("hello-2");
}
System.out.println("hello-3");
```

以上代码会输出如下：
hello-2
hello-3

### try-catch-finally

* finally是可选的
* 使用try将可能出现异常的代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常类的对象，根据此对象的类型，去catch中进行匹配
* 一旦try中的异常对象匹配到了某一个catch时，就进入catch中进行异常的处理，处理完成后就跳出了当前的try-catch结构(在没有写finally的情况)，继续执行其后的代码
* 多个catch中的异常类型，如果没有子父类的关系，则上下的顺序没有影响
* 多个catch中的异常类型，如果有子父类的关系，那么子类应该列在上面，否则，下面的catch将不可达，编译报错
* 常见的异常对象处理方式：`getMessages()`,`printStackTrace()`
* 在try结构中声明的变量，离开try{}之外的地方不能再被调用
* 通过try-catch捕获异常后则可以继续运行后面的代码
* 如果出现的异常没有匹配到在catch里列的众多异常，则仍会报错，导致整个程序停下来
* try-catch结构可以相互嵌套
* finally里面的代码一定会执行，除非try-catch里面有`System.exit(0)`，否则即使是try里面有return语句也会去执行finally里的代码
* 如果try,catch,fianlly里面都有return，则最终会return的是finally的返回

```java
public class Test{
    public static int test(){
        try{
            System.out.println("hello");
            return 1;
        }catch (Exception e){
            return 2;
        }finally {
            System.out.println("finally");
            return 4;
        }
    }

    public static void main(){
        System.out.println(test());//4
    }
}
```

```java
public class Test{
    public static int test(){
        int num=4;
        try{
            System.out.println("hello");
            return --num;//此时返回值已经产生,到了操作数栈，只是又去执行了finally
        }catch (Exception e){

        }finally {
            System.out.println("finally");
            ++num;//局部变量此时自加，但是返回值已经生成，除非此处是return语句，则会覆盖try里的返回值
        }
        return num;//此处的代码没有执行
    }

    public static void main(){
        System.out.println(test());//3
    }
}
```

> 使用try-catch-finally处理编译时异常，使得程序在编译时不再报错，但是运行时也可能会出现报错

### throws

* 格式：`throws 异常类型`
* `throws 异常类型`写在方法声明处，指明此方法执行时，可能会抛出的异常类型
* 一旦方法体执行时出现异常，仍会在异常代码处生成一个异常类的对象，此对象满足throws后的异常类型时，就会被抛出，上层的调用处也要进行异常的处理，要么try-catch,那么继续向上抛，try-catch处理之后就不会再继续抛，但是如果继续throws且一直不处理，则JVM会进行报错，停止运行
* try-catch-finally是在处理异常，throws的方式只是将异常抛给了方法的调用者，并没有真正处理异常
* 如果异常部分被try-catch处理，方法体又使用throws，代码语法没有问题，但是异常已被try-catch,throws其实不会发生，这是多余的写法

### 方法重写时的异常规则

* 子类重写的方法抛出的异常不能大于父类方法抛出的异常范围，因为如果在多态下，一个地方调用了父类引用中的方法，那么此处要处理这个重写方法的异常，但是多态可能会使得在运行时执行子类对象方法，如果此时子类的异常比父类还要大，那么此处的异常类型就无法确定了
* 父类方法如果没有抛出异常，那么子类也不能抛出异常，也就是说如果子类有异常，就只能选择try-catch来处理，不能向上抛异常

### 如果选择异常处理方式

* 如果一个流程需要多个方法按照顺序来执行，且这多个方法都可能会有异常，那么可以选择将它们throws，向上抛给这几个方法的调用者位置，然后在调用处进行try-catch处理，另一个原因是这个流程是按照顺序执行，那么前一个出现了异常，那么后面的工序应该被停止，如果在每个方法内部去处理异常，会使得方法进行执行，这是不符合要求的

## 5.3 throw关键字

* 异常的产生可以分为：①系统自动生成的异常对象②手动的生成一个异常对象，并抛出
* 格式：`throw new 异常类型("描述")`
* 如果抛出的异常类型是运行时异常RuntimeException，则不显式需要try-catch-finally与throws进行处理(编译可以通过)，但是如果抛出的是非运行时异常，则此时手动抛出的异常还需要去进行处理（因为编译都无法通过，必须处理）

```java
public void getMonth(){
    Scanner sc=new Scanner(System.in);
        int inputMonth=sc.nextInt();
        if(inputMonth>0&&inputMonth<13){
            //
        }else{
            new RuntimeException("输入的月份合法："+inputMonth);//抛出异常后程序会停止运行
    }
}
```

## 5.3 用户自定义异常类

* 继承于现有的异常结构：RuntimeException、Exception
* 提供全局常量：serialVersionUID
* 提供重载的构造器

```java
class MyException extends RuntimeException{
    static final long serialVersionUID = -7034897190745766939L;

    public MyException(){

    }
    public MyException(String msg){
        super(msg);
    }
}
```

## 总结

throw和throws的区别(从位置，作用来区别)

throw在方法体内，手动抛出一个异常对象；throws在方法声明的位置，是一种异常处理的方式，表明方法体内执行出现异常，则向此方法的调用者传递该异常，让调用的位置去决定怎么处理该异常
