# 运算符

> 运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等

- 算术运算符

- 赋值运算符

- 比较运算符（关系运算符）

- 逻辑运算符

- 位运算符

- 三元运算符

# 算术运算符

| 运算符 | 运算           | 范例         | 结果      |
| --- | ------------ | ---------- | ------- |
| +   | 正号           | +3         | 3       |
| -   | 负号           | b=4;-b     | -4      |
| +   | 加            | 5+5        | 10      |
| -   | 减            | 6-4        | 2       |
| *   | 乘            | 3\*4        | 12      |
| /   | 除            | 5/5        | 1       |
| %   | 取模（取余）       | 7%5        | 2       |
| ++  | 自增（前）：先自增后取值 | a=2;b=++a; | 3       |
| ++  | 自增（后）：先取值后自增 | a=2;b=a++; | 2       |
| --  | 自减（前）：先自减后取值 | a=2;b=--a; | 1       |
| --  | 自减（后）：先取值后自减 | a=2;b=a--; | 2       |
| +   | 字符串连接        | "He"+"llo" | "Hello" |

## 取余运算

- 被模数%模数=结果

- 结果的符号与被模数的符号相同

## 自增、自减

- 自加、自减符号在数据的前后位置不同，可能导致参与运算得到的值不同，根本原因是自增、自减运算优先级低于赋值运算符，放在前面则就只能先进行算术运算后赋值

- 自增1，自减1不会改变本身变量的数据类型，如:

```java
byte b=127;
b++;//此时b=-128;
```

- 不能连续自增或者自减

```java
int i=3;
i++++;//编译不通过
(i++)++;//编译不通过
```

## 问题

```java
public class Exam1 {
    public static void main(String[] args) {
        int i = 88;
        i = i++;
    }
}
```

```
$ javap -c Exam1
Compiled from "Exam1.java"
public class Exam1 {
  public Exam1();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return

  public static void main(java.lang.String[]);
    Code:
       0: bipush        88
       2: istore_1
       3: iload_1
       4: iinc          1, 1
       7: istore_1
       8: return
}
```

bipush 将局部的常量入栈到操作数栈
istorre_1 将操作数栈中的第一个数取出来  ,这里也就是将88赋值给变量i
iload_1 将局部的变量中的第一个变量值存入到操作数栈中，也就是因为要执行i++，于是把i的值放入了操作栈里了
iinc 将第一个局部变量自加1    也就是将i自加
istore_1 将操作数栈中的第一个数取出来   ，也就是说把第三步中放进去的数取出来了，赋给了变量i

i=i++，也可以理解成
temp=i;
i=i+1;
i=temp

i=++i,也可以理解成
i=i+1;
temp=i;
i=temp;
（当然不同的语言顶层实现这个++、--制定的规则不同，c语言就不是这样）